load(String.raw`
	(1)(Class)Geometry(/1)
	(p)
		The Geometry class is a static class with methods for doing common geometric operations, often on #Shape#s and #Array#s.
	(/p)
	(2)Methods(/2)
	(p)
		(method:smoothConnector@path@$Vector2[]$)
			Returns a smoothed version of a given set of points. Sharp corners formed by connecting all of the points will be less sharp in the result.
			(2)Parameters(/2)
			(p2)
				(param:path $Vector2[]$)The path to be smoothed.(/param)
			(/p2)
		(/method)
		(method:smoothPolygon@polygon@$Polygon$)
			Returns a smoothed version of a given #Polygon#. Sharp corners will be less sharp in the result.
			(2)Parameters(/2)
			(p2)
				(param:path $Polygon$)The polygon to be smoothed.(/param)
			(/p2)
		(/method)
		(method:triangulate@polygon@$Vector2[3][]$)
			Returns a list of 3 points lists representing the vertices of triangles that when viewed as a set make up the entirety of the given convex #Polygon#.
			(2)Parameters(/2)
			(p2)
				(param:polygon $Polygon$)The #Polygon# to trianglulate.(/param)
			(/p2)
		(/method)
		(method:gridToPolygons@grid, cellSize@$Polygon[]$)
			Returns a #Polygon# hull for the provided boolean grid. Islands are usually preserved.
			(2)Parameters(/2)
			(p2)
				(param:grid $Boolean[][]$)A 2D array of true or false to be converted to polygons.(/param)
				(param:cellSize $Number$)The side length of one square in the grid.(/param)
			(/p2)
		(/method)
		(method:gridToRects@grid, cellSize@$Rect[]$)
			Uses a greedy algorithm to construct the smallest number of rectangles that when viewed together form the same contours as the provided boolean grid.
			(2)Parameters(/2)
			(p2)
				(param:grid $Boolean[][]$)A 2D array of true or false to be converted to rectangles.(/param)
				(param:cellSize $Number$)The side length of one square in the grid.(/param)
			(/p2)
		(/method)
		(method:closest@center, points@$Vector2$)
			Returns the point that is the closest to a given point.
			(2)Parameters(/2)
			(p2)
				(param:center $Vector2$)The point which the other points check their distance to.(/param)
				(param:points $Vector2[]$)The points from which the closest can be chosen.(/param)
			(/p2)
		(/method)
		(method:farthest@center, points@$Vector2$)
			Returns the point that is the farthest from a given point.
			(2)Parameters(/2)
			(p2)
				(param:center $Vector2$)The point which the other points check their distance to.(/param)
				(param:points $Vector2[]$)The points from which the farthest can be chosen.(/param)
			(/p2)
		(/method)
		(method:signedAngularDist@theta, phi@$Number$)
			Returns the lowest magnitude rotation to get from one angle to another.
			(2)Parameters(/2)
			(p2)
				(param:theta $Number$)The starting angle.(/param)
				(param:phi $Number$)The destination angle.(/param)
			(/p2)
		(/method)
		(method:rayCast@rayOrigin, rayDirection, shapes@$Object$)
			Casts the provided ray against the provided #Shape#s and returns an Object in the form *{ hitPoint, hitShape }* where hitPoint is the point where the ray intersected the shape or null if it didn't, and hitShape is the #Shape# that was hit, or null if none were.
			(2)Parameters(/2)
			(p2)
				(param:rayOrigin $Vector2$)The starting point of the ray.(/param)
				(param:rayDirection $Vector2$)The direction of the ray. Should be normalized.(/param)
				(param:shapes $Shape[]$)The #Shape#s that should be tested for intersection with the ray.(/param)
			(/p2)
		(/method)
		(method:subdividePolygon@polygon@$Polygon[]$)
			Returns a convex decomposition of the given concave or convex polygon.
			(2)Parameters(/2)
			(p2)
				(param:polygon $Polygon$)The polygon to be decomposed.(/param)
			(/p2)
		(/method)
		(method:intersectRayLine@rayOrigin, rayDirection, line@$Vector2$)
			Returns where a given ray intersects a given line, or null if it doesn't.
			(2)Parameters(/2)
			(p2)
				(param:rayOrigin $Vector2$)The starting point of the ray.(/param)
				(param:rayDirection $Vector2$)The direction of the ray. Should be normalized.(/param)
				(param:line $Line$)The #Line# for the ray to be cast against.(/param)
			(/p2)
		(/method)
		(method:overlapLineLine@lineA, lineB@$Boolean$)
			Returns whether or not two given #Line#s intersect.
			(2)Parameters(/2)
			(p2)
				(param:lineA $Line$)The first line to check for intersection.(/param)
				(param:lineB $Line$)The second line to check for intersection.(/param)
			(/p2)
		(/method)
		(method:overlapShapes@shapeA, shapeB@$Boolean$)
			Returns whether or not two given #Shape#s intersect (#Polygon#s must be convex).
			(2)Parameters(/2)
			(p2)
				(param:shapeA $Shape$)The first #Shape# to check for intersection.(/param)
				(param:shapeB $Shape$)The second #Shape# to check for intersection.(/param)
			(/p2)
		(/method)
		(method:overlapPoint@point, shape@$Boolean$)
			Returns whether or not the given point is inside the given #Shape# (#Polygon#s must be convex).
			(2)Parameters(/2)
			(p2)
				(param:point $Vector2$)The point to check.(/param)
				(param:shape $Shape$)The #Shape# to check if the point is inside of.(/param)
			(/p2)
		(/method)
		(method:closestPointOn[Polygon, Rect, Circle, Line]@point, shape@$Vector2$)
			Returns the closest point to a given point on a given #Shape#.
			(2)Parameters(/2)
			(p2)
				(param:point $Vector2$)The reference point.(/param)
				(param:shape $Shape$)The shape to get the closest point on.(/param)
			(/p2)
		(/method)
		(method:distTo[Polygon, Rect, Circle]@point, shape@$Number$)
			Returns the distance from a given point to a given #Shape#.
			(2)Parameters(/2)
			(p2)
				(param:point $Vector2$)The point to get the distance from.(/param)
				(param:shape $Shape$)The #Shape# that the distance to is being checked.(/param)
			(/p2)
		(/method)
		(method:pointInside[Polygon, Rect, Circle]@point, shape@$Boolean$)
			Returns whether or not a given point is inside a given #Shape# (#Polygon#s must be convex).
			(2)Parameters(/2)
			(p2)
				(param:point $Vector2$)The point to check.(/param)
				(param:shape $Shape$)The #Shape# to check if the point is inside of.(/param)
			(/p2)
		(/method)
		(method:overlap[PolygonPolygon, RectRect, CircleCircle]@shapeA, shapeB@$Boolean$)
			Returns whether of not the two #Shape#s of the same type overlap (#Polygon#s must be convex). This method is often faster than using *Geometry.overlapShapes(shapeA, shapeB)*.
			(2)Parameters(/2)
			(p2)
				(param:shapeA $Shape$)The first #Shape# to check.(/param)
				(param:shapeB $Shape$)The second #Shape# to check.(/param)
			(/p2)
		(/method)
	(/p)
`);