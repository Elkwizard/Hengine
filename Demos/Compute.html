<script src="../Hengine.js">
	title = "Hengine Demos - Compute Shaders";

	// set background
	canvas.clearScreen = () => renderer.fill(Color.BLACK);

	// declare spawner domain
	const domain = new Circle(middle, Math.min(width, height) / 2);

	// create & setup particle spawner, with a compute shader for updates
	const spawner = scene.main.addElement("particles", middle);
	spawner.scripts.add(PARTICLE_SPAWNER, {
		delay: 0.01, // time between particle creation, in frames
		lifeSpan: Infinity, // they don't need to go away
		active: false, // we'll activate this manually
		cullGraphics: false, // all the particles will be on screen
		init(particle) { // called on particle creation
			particle.position = Random.inShape(domain);
			
			// define custom data properties
			particle.data.color = new Color(0, 255, 255);
			particle.data.color.red = 0;
			particle.data.size = Random.range(0.5, 1);
			particle.data.proportion = 1;
		},
		// this is run for every particle, in parallel, on the GPU
		update: ` 
			// declare the data shape of our custom properties
			struct Data {
				vec2 color; // we only need the first component
				float proportion;
			};

			// declare the data shape of the particle
			struct Particle {
				vec2 position, velocity;
				Data data;
			};

			// declare computation inputs
			uniform vec2 mouse;
			uniform bool mouseHeld;
			uniform Particle[] particles;

			Particle compute() {
				Particle particle = particles[problemIndex];

				particle.data.proportion = 4.0 * (0.3 * particle.data.color.r + 0.1);

				// move towards mouse, and redden color
				if (mouseHeld) {
					vec2 diff = mouse - particle.position;
					float sqrDist = dot(diff, diff);
					diff *= 100.0 / max(sqrDist, 1000.0);
					particle.velocity += diff;
					particle.data.color.r += length(diff) / 20.0;
				}

				particle.data.color.r = clamp(particle.data.color.r, 0.0, 1.0);

				// damp the velocity
				particle.velocity *= 0.95;
				particle.data.color.r *= 0.95;
				
				// integrate velocity
				particle.position += particle.velocity;

				return particle;
			}
		`,
		draw(renderer, particle) { // called for particle rendering
			renderer.draw(particle.data.color).circle(
				particle.position,
				particle.data.proportion * particle.data.size
			);
		}
	});

	spawner.scripts.PARTICLE_SPAWNER.explode(10000);

	// whether or not the program should move the particles on its own
	let userControlled = false;
	const autoDirection = Vector2.right;

	// create main loop to provide user input to the GPU
	intervals.continuous(time => {
		// fetch the GPUComputation instance
		const { computation } = spawner.scripts.PARTICLE_SPAWNER;

		// more particles!!
		if (keyboard.justPressed("Enter")) {
			spawner.scripts.PARTICLE_SPAWNER.explode(keyboard.pressed("Shift") ? 10000 : 2000);
		}

		if (mouse.pressed("Left")) userControlled = true;

		// set computation inputs
		if (userControlled) { // let the user move particles
			computation.setUniforms({
				mouse: mouse.screen,
				mouseHeld: mouse.pressed("Left")
			});
		} else if (time > 200) { // automatically move particles
			const LOOP_LENGTH = 100;
			const HOLD_LENGTH = LOOP_LENGTH * 0.5;
			const DRAG_LENGTH = (LOOP_LENGTH - HOLD_LENGTH) * 0.4;
			const loopTime = time % LOOP_LENGTH;
			if (loopTime < HOLD_LENGTH) {
				computation.setUniforms({
					mouse: middle, mouseHeld: true
				});
				autoDirection.rotate(Random.angle());
			} else {
				const postHoldTime = loopTime - HOLD_LENGTH;
				computation.setUniforms({
					mouse: middle.plus(autoDirection.times(postHoldTime ** 2)),
					mouseHeld: postHoldTime < DRAG_LENGTH
				});
			}

			// slightly shift random direction
			autoDirection.rotate(Random.range(0.1));
		}
	}, IntervalFunction.BEFORE_UPDATE);

	// show directions on top layer
	intervals.continuous(() => {	
		const count = spawner.scripts.PARTICLE_SPAWNER.particleCount;
		ui.draw(Color.WHITE).text(Font.Arial30, `Left Click and Drag to Swirl ${count / 1000}K particles`, 10, 10);
		ui.draw(Color.WHITE).text(Font.Arial20, "Hold, wait, then toss the particles for best results.\nPress Enter for more particles\nPress Shift+Enter for a lot more particles", 10, 40);
	}, IntervalFunction.AFTER_UPDATE);
</script>