<script src="../Hengine.js">
	title = "Hengine Demos - Shader Editor";

	const STARTER_CODE = `
// === Fractal Shader Demo ===
// This is the Hengine's GPUShader system, made interactive.
// Simply edit the GLSL code here, and press Alt + Enter to
// see your changes come to life!

uniform float time;
uniform vec2 mouse;

// try changing these!
#define ITERATIONS 5 // the level of detail
#define OMEGA 0.01 // the rotation speed
#define BAND 0.4 // something (:

vec2 transform(vec2 uv) {
	// repeat
	uv = mod(uv, 0.5) * 2.0;

	// reflect
	uv = abs(uv - 0.5) + 0.5;

	// rotate
	uv -= 0.5;
	float angle = time * OMEGA;
	float c = cos(angle);
	float s = sin(angle);
	uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
	uv += 0.5;

	return uv;
}

vec4 shader() {
	vec2 uv = position / resolution.x;

	for (int i = 0; i < ITERATIONS; i++)
		uv = transform(uv);

	if (abs(uv.x - 0.5) > BAND * 0.5) return vec4(0);

	return vec4(uv, 1, 1);
}`;

	canvas.clearScreen = () => renderer.fill(Color.BLACK);

	// define behavior for code input
	class CODE_INPUT extends ElementScript {
		init(obj, initialValue, onCompile) {
			obj.scripts.removeDefault();
			this.scriptNumber--;
			
			this.font = Font.Monospace20;
			this.boldFont = this.font.bold();
			
			obj.scripts.add(TEXT_AREA, this.font);

			this.text = obj.scripts.TEXT_AREA;
			this.text.alwaysIgnore("Alt");
			this.text.caretColor = Color.WHITE;
			this.text.highlightColor = new Color(255, 255, 255, 0.4);
			this.text.setValue(initialValue);
			this.onCompile = onCompile;

			this.compile();

			// setup syntax highlighting
			this.text.renderTextOffset = new Vector2(50, 0);
			this.text.renderText = (text, font, pos, getLoc, lineIndex) => {
				// draw line number
				ui.draw(Color.WHITE).text(font, lineIndex + 1, pos);

				// draw tab stops
				const tabs = text.match(/^\t+/g)?.[0]?.length ?? 0;
				const tabWidth = font.getTextWidth("\t");
				for (let i = 0; i < tabs; i++) {
					const { x, y } = pos
						.plus(this.text.renderTextOffset)
						.plus(Vector2.x(i * tabWidth));
					ui.draw(Color.GRAY).rect(x, y, 1, font.lineHeight);
				}

				// highlight code
				const formats = Array.dim(text.length).map(() => ({
					color: new Color("#ddd"),
					font: this.font
				}));

				const highlight = (color, regex, font = this.font) => {
					const format = { color, font };
					for (const { [0]: matched, index } of text.matchAll(regex)) {
						for (let i = 0; i < matched.length; i++) {
							formats[index + i] = format;
						}
					}
				};
				
				highlight(new Color("#a5a"), /\b((a?(sin|cos|tan))|length|dot|cross|texture|clamp|normalize|min|max|ceil|smoothstep|round|floor|mod|sqrt|mix|pow|abs|float|int|bool|sampler2D|mat[234]|([uib]?vec[234]))\b/g);
				highlight(new Color("#88d"), /\b\w[\w\d_]*(?=\s*\()/g);
				highlight(new Color("#faf"), /[^\w\s]+/g);
				highlight(new Color("#c5c"), /\b(return|struct|void|in|out|(low|medium|high)p|uniform|position|resolution|shader|for|continue|break|if|else|define)\b/g);
				highlight(new Color("#aad"), /(?<=\.)\w[\w\d_]*/g);
				highlight(new Color("#fd1"), /\b((\d+(\.\d+)?([eE][+-]?\d+)?)|(true|false))\b/g);
				highlight(new Color("#898"), /\/\/(.*)|\/\*(.*?)($|\*\/)|(^|\/\*)(.*?)\*\//g, this.boldFont);

				// render highlighted code in chunks
				let currentFormat = formats[0];
				let acc = "";
				for (let i = 0; i < formats.length; i++) {
					const format = formats[i];
					acc += text[i];
					const nextFormat = formats[i + 1];
					if (currentFormat !== nextFormat) {
						const pos = getLoc(1 + i - acc.length).plus(this.text.renderTextOffset);
						const { color, font } = currentFormat;
						ui.draw(color).text(font, acc, pos);
						currentFormat = nextFormat;
						acc = "";
					}
				}
			};
		}
		compile() {
			this.onCompile(this.text.getValue());
		}
		update(obj) {
			if (keyboard.pressed("Alt") && keyboard.justPressed("Enter")) {
				this.text.ignore("Enter");
				this.compile();
			}
		}
		draw(obj, name, shape) {
			ui.draw(Color.DARK_GRAY).rect(shape);
			ui.stroke(Color.WHITE).rect(shape);
		}
	}
	
	let error;
	let time = 0;
	let webcam = null;

	const shader = new GPUShader(width / 2, height, `vec4 shader() { return vec4(0); }`, canvas.pixelRatio);
	const codeInput = scene.main.addUIElement("codeInput", width * 0.75, height / 2, width / 2, height);
	codeInput.scripts.add(CODE_INPUT, STARTER_CODE, code => {
		try {
			shader.glsl = code;
			error = null;
		} catch (err) {
			error = err;
		}

		time = 0;
	});
	
	// main shader loop
	intervals.continuous(() => {
		if (keyboard.pressed("Alt") && keyboard.justPressed("Enter")) {
			try {
				shader.glsl = codeInput.scripts.CODE_INPUT.value;
				error = null;
			} catch (err) {
				error = err;
			}

			time = 0;
		}
		
		// maybe setup webcam
		if (shader.hasUniform("webcam") && !webcam) {
			webcam = new Frame(1, 1);
			new HengineWebcamResource("wc").load().then(wc => webcam = wc);
		}

		// set shader uniforms
		shader.setUniforms({
			webcam,
			time: time++,
			mouse: mouse.screen
		}, false /* don't warn on unused uniforms */);

		// run and render shader
		renderer.image(shader).default(0, 0);
	}, IntervalFunction.UPDATE);
	
	// top-layer UI loop
	intervals.continuous(() => {
		if (error) { // display error message
			const PADDING = 10;
			const FONT = Font.Monospace20;
			const text = FONT.packText(error.toString().trim(), width / 2);
			const bounds = FONT.getTextBounds(text);
			const rect = new Rect(
				0, 0,
				bounds.width + PADDING * 2,
				bounds.height + PADDING * 2
			);

			ui.textMode = TextMode.TOP_LEFT;
			ui.draw(Color.BLACK).rect(rect);
			ui.stroke(Color.WHITE).rect(rect);
			ui.draw(Color.RED).text(FONT, text, PADDING, PADDING + FONT.lineHeight * 0.1);
		}

		ui.textMode = TextMode.BOTTOM_LEFT;
		ui.draw(Color.RED).text(Font.Monospace40, `${intervals.fps} Hz`, 10, height - 10);
	}, IntervalFunction.AFTER_UPDATE);
</script>